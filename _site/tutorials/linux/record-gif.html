<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <!-- Improve output on mobile devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Begin font CSS files -->
    <link rel="stylesheet" href="/assets/fonts/cm/Sans/cmun-sans.css">
    <link rel="stylesheet" href="/assets/fonts/cm/Typewriter/cmun-typewriter.css">
    <!-- End font CSS files -->

    <link rel="stylesheet" href="/assets/css/styles.css">
    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="BonfireAtNight" />
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>BonfireAtNight | Persönliche Webseite von Kai Breucker.</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="BonfireAtNight" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Persönliche Webseite von Kai Breucker." />
<meta property="og:description" content="Persönliche Webseite von Kai Breucker." />
<link rel="canonical" href="http://localhost:4000/tutorials/linux/record-gif.html" />
<meta property="og:url" content="http://localhost:4000/tutorials/linux/record-gif.html" />
<meta property="og:site_name" content="BonfireAtNight" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="BonfireAtNight" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Persönliche Webseite von Kai Breucker.","headline":"BonfireAtNight","url":"http://localhost:4000/tutorials/linux/record-gif.html"}</script>
<!-- End Jekyll SEO tag -->

  </head>
  <body>
    <article class="markdown-body">
      <nav class="topnav">
  <header>
  <ul style="white-space: nowrap;">
    <li><a href="/index.html">Home</a></li>
    <li><a href="/blog.html">Blog</a></li>
    <li><a href="/tutorials.html">Tutorials</a></li>
    <li><a href="/theory.html">Theorie</a></li>
    <li><a href="/contact.html">Kontakt</a></li>
  </ul>
  </header>
</nav>


      <h1 id="wie-man-gif-screencasts-aufnimmt">Wie man GIF-Screencasts aufnimmt</h1>
<p>Um Tutorials im Software-Bereich zu illustrieren, können kurze Bildschirmaufnahmen im GIF-Format sehr hilfreich sein.
Als ich an meinem ersten Artikel für diese Website gearbeitet habe, wollte ich schnell einige solche bewegten Bilder erstellen.
Wie sich herausstellte, ist es tatsächlich gar nicht so einfach, eine zufriedenstellende Lösung für diese Aufgabe zu finden.
In zwei Tagen habe ich eine Vielzahl von Anwendungen ausprobiert, wobei die meisten sich aus dem einen oder anderen Grund als unzulänglich herausstellten. 
Ich habe mich deshalb entschieden, meinen ersten Artikel auf dieser Webseite diesem Problem zu widmen.</p>

<p>Im Folgenden werde ich zunächst präzisieren, was ich von der gesuchten Anwendung erwarte.
Aufgrund der sehr spezifischen Anforderungen und Voraussetzungen, kann dieser Artikel vielleicht nur wenigen potenziellen Lesern von Nutzen sein.
Das liegt in der Natur der Sache.
Vielleicht kann man sogar sagen, dass sich die <a href="http://www.catb.org/~esr/writings/taoup/html/ch01s06.html">Unix-Philosophie</a> auch auf das Schreiben von Artikeln übertragen lässt: Es ist besser, ein klar umgrenztes Problem zu lösen, als den Versuch zu unternehmen, eine <em>one size fits all</em>-Antwort für unterbestimmte Anforderungen zu formulieren.</p>

<p>Im Anschluss daran werde ich einen Überblick über die populärsten Screencast-Anwendungen geben, die für Linux zur Verfügung stehen.
Statt sie im Detail vorzustellen, beschränke ich mich auf knappe Hinweise, warum sie den zuvor definierten Anforderungen nicht gerecht werden.
Für interessierte Leser verlinke ich lediglich auf die entsprechenden Webseiten.</p>

<p>Mit Byzanz ist es sehr einfach, Bildschirmaufnahmen zu erstellen und als GIF zu speichern.
Um seine Bedienung noch komfortabler zu gestalten, werde ich ein kleines Shell-Skript vorstellen.</p>

<h2 id="anforderungen">Anforderungen</h2>
<p>Für eine einfache Handhabbarkeit sollte das Programm möglichst wenig tun, seine wenigen Aufgaben aber zufriedenstellend erfüllen.
Da es mir nur um ein einfaches GIF geht, brauche ich keine umfangreichen Videoaufnahmen, gerade auch aus Gründen der Performance während der Aufnahme.
Im Idealfall kann das Programm über die Kommandozeile ausgeführt werden und beschränkt sich darauf, Bildschirmaktivität aufzunehmen und als GIF-Datei zu speichern.
Als Zusatzoptionen sollte man eine Verzögerung vor der Aufnahme, eine Gesamtaufnahmelänge und den aufzunehmenden Bereich oder das aufzunehmende Fenster festlegen können.</p>

<p>Viele Anwendungen erlauben dadurch ein bequemeres (vielleicht produktiveres) Arbeiten, dass sie vor allem über die Tastatur bedient werden können.
Sollen Tutorials über solche Anwendungen mit Videos illustriert werden, ist es deshalb vonnöten, dass nicht nur der sichtbare Bereich auf dem Bildschirm aufgenommen wird, sondern auch die Tastenanschläge visualisiert werden.
Das gesuchte Programm sollte deshalb auch die Ausgabe eines Programms wie <a href="https://gitlab.com/screenkey/screenkey">Screenkey</a> aufzeichnen können.</p>

<p>Statt den gängigen Desktops setzen sich in der Linux-Welt und unter MacOS-Nutzern immer mehr Fenstermanager durch.
Daraus können sich besondere Probleme bei der Aufnahme des sichtbaren Bildschirmbereiches ergeben.
Die gesuchte Anwendung sollte deshalb im besten Fall auch in einer Umgebung ohne Desktop einsetzbar sein, nach Möglichkeit ohne großeren Konfigurationsaufwand.
Persönlich nutze ich <a href="https://i3wm.org/">i3</a> und bei der Auswahl eines Programms habe ich vor allem auf Kompatibilität zu diesem bestimmten Fenstermanager geachtet.</p>

<h2 id="überblick-über-verfügbare-screencast-apps">Überblick über verfügbare Screencast-Apps</h2>
<p>Einige Linux-YouTuber (wie <a href="https://www.youtube.com/watch?v=_UNRVybAJTs&amp;t=1054s">Distrotube</a> oder <a href="https://www.youtube.com/watch?v=TpsfdPj0juA">Brodie Robertson</a>) verwenden für ihre Screencasts <a href="https://obsproject.com/">OBS Studio</a>.
Auch wenn die freie und quelloffene Anwendung sicher hervorragend ist, so bietet sie weitaus mehr Features, als ich für meine Zwecke benötige.
In vielen Foren wird <a href="https://ffmpeg.org/">FFmpeg</a> empfohlen, mit dem Videos aufgenommen und im Anschluss zu GIF-Dateien umgewandelt werden können.
Wenn das Programm auch relativ einfach zu handhaben ist und über die Kommandozeile bedient werden kann, so wäre mir eine direktere und auf GIF-Dateien beschränkte Lösung lieber.
Darüber hinaus stellte es sich in einem kurzen Test als eher ressourcenintensiv heraus.
Ähnliches gilt für den nicht länger gewarteten <a href="https://launchpad.net/kazam">Kazam Screencaster</a>, das sich weiter aktiv in Entwicklung befindliche <a href="https://github.com/vkohaupt/vokoscreenNG">Vokoscreen-NG</a> und den irreführend benannten <a href="https://www.maartenbaert.be/simplescreenrecorder/">SimpleScreenRecorder</a>.
Gemeinsam ist diesen graphischen Tools auch ihre meinem Empfinden nach eher wenig ansprechende Benutzeroberfläche.</p>

<p>Zwei weitere populäre Anwendungen, <a href="https://github.com/phw/peek">Peek</a> und <a href="https://github.com/colinkeenan/silentcast">Silentcast</a> vertragen sich schlecht mit meinem Fenstermanager.
Da die von Peek genutzte X Shape Extension von i3 <a href="https://github.com/phw/peek#on-i3-the-recording-area-is-all-black-how-can-i-record-anything">nicht unterstützt</a> wird, müsste eine Compositor (wie Compton) verwendet werden.
Auch wenn Silentcast eine <a href="https://github.com/colinkeenan/silentcast#tiling-window-managers">Anleitung</a> gibt, um die i3-Konfigurationsdatei entsprechend den Anforderungen anzupassen, so würde es nicht out-of-the-box funktionieren und gegebenenfalls weitere Probleme nach sich ziehen.
Die Verwendung beider Programme ist beim gegebenen Setting also mit einem nicht geringen Mehraufwand verbunden.</p>

<p>Verschiedene CLI-Anwendungen – darunter das zumeist vorinstallierte <a href="https://linux.die.net/man/1/screen">GNU Screen</a>, <a href="https://github.com/faressoft/terminalizer">Terminalizer</a>, <a href="https://asciinema.org/">asciinema</a> und <a href="https://github.com/chjj/ttystudio">ttystudio</a> – dienen dem Zweck, Terminal-Sessions aufzuzeichnen.
In Kombination mit <a href="https://github.com/asciinema/agg">agg</a> war asciinema eine weitgehend zufriedenstellende Lösung.
In einigen Fällen ist es aber zweckdienlich, auch Tastenanschläge auf dem Bildschirm anzuzeigen.
Um diese Ausgaben zusätzlich zur Terminal-Aktivität aufzuzeichnen, ist eine Aufnahme von mehr als nur dem Terminal nötig.</p>

<p><a href="https://gitlab.gnome.org/Archive/byzanz">Byzanz</a> ist ein weiteres Tool für die Kommandozeile, das häufig empfohlen wird.
Es sprach mich zunächst deshalb an, weil es in seiner Selbstdarstellung genau die Prinzipien zum Ausdruck bringt, wie man sie sich vielleicht von jeder Software wünschen würde.
Zwar liegt der letzte Release der CLI-Anwendung schon etliche Jahre zurück, doch es erfüllt das gesetzte Ziel völlig zufriedenstellend.
Im folgenden Abschnitt werde ich die Einzelheiten eines Workflows erläutern, mit dem das hier gestellte Problem auf äußerst komfortable Weise gelöst wird.</p>

<h2 id="aufnahmen-mit-byzanz">Aufnahmen mit Byzanz</h2>
<p>Wie die <code class="language-plaintext highlighter-rouge">man</code>-Page <a href="https://linux.die.net/man/1/byzanz-record">erläutert</a>, wird eine Aufnahme mit Byzanz durch einen Befehl der folgenden Form gestartet:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> byzanz-record <span class="o">[</span>options] FILENAME
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">FILENAME</code> steht dabei für den Namen der GIF-Datei, die erstellt werden soll.</p>

<p>Das Programm unterstützt zwei Ausführungsmodi:</p>
<ol>
  <li>Durch die Option <code class="language-plaintext highlighter-rouge">-d=WERT</code> wird die Länge der Aufzeichnung (<em>duration</em>) in Sekunden angeben. Wird dieser Wert nicht ausdrücklich festgelegt, so wird die Aufnahme nach zehn Sekunden beendet.</li>
  <li>Durch die Option <code class="language-plaintext highlighter-rouge">-e="COMMAND"</code><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">1</a></sup> wird ein Befehl übergeben, der mit Beginn der Aufnahme ausgeführt wird (<em>execute</em>).<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">2</a></sup> Die Aufzeichnung endet, wenn das aufgerufene Programm beendet wird.</li>
</ol>

<p>Um sich eine Vorbereitungszeit zu gönnen, kann für beide Modi festgelegt werden, nach wie vielen Sekunden die Aufnahme beginnen soll.
Dazu wird <code class="language-plaintext highlighter-rouge">--delay=WERT</code> gesetzt.
Der Defaultwert beträgt hier eine Sekunde.</p>

<h3 id="aufnahme-eines-bildschirmbereiches">Aufnahme eines Bildschirmbereiches</h3>
<p>Standardmäßig wird durch <code class="language-plaintext highlighter-rouge">byzanz-record</code> der gesamte sichtbare Bereich des Bildschirms aufgenommen.
Das ist häufig nicht zweckmäßig, da ein zu großer Aufnahmebereich vom Wesentlichen ablenken kann.
Ein eingeschränkter Bereich kann auch genutzt werden, um persönliche Informationen zu verbergen, die sonst in der Aufnahme sichtbar wären.</p>

<p>Vier Byzanz-Optionen dienen dazu, den Aufnahmebereich in Form eines Rechtecks zu definieren.
Mit <code class="language-plaintext highlighter-rouge">-x</code> und <code class="language-plaintext highlighter-rouge">-y</code> werden die x- und y-Koordinaten des Rechtecks (in Pixeln) angeben, und mit <code class="language-plaintext highlighter-rouge">-w</code> (<code class="language-plaintext highlighter-rouge">--width</code>) und <code class="language-plaintext highlighter-rouge">-h</code> (<code class="language-plaintext highlighter-rouge">--height</code>) werden Breite und Höhe des Rechtecks (in Pixeln) festgelegt.
One weitere Hilfsmittel bleibt es der Vorstellungskraft des Nutzers überlassen, ein Rechteck auf dem Bildschirm abzustecken.
Wenn man die Bildschirmauflösung seines Computers kennt, kann man grob abschätzen, wo die Koordinaten des vorgestellten Rechtecks liegen würde.</p>

<p>Zum Glück gibt es Tools, die es dem Nutzer ermöglichen, mit der Maus ein sichtbares Rechteck zu ziehen.
Das minimalistische <a href="https://github.com/ropery/xrectsel">xrectsel</a>, das unter anderem im Arch User Repository <a href="https://aur.archlinux.org/packages/xrectsel">befindet</a> verfügbar ist, eignet sich hervorragend zu diesem Zweck. 
Führt man <code class="language-plaintext highlighter-rouge">xrectsel</code> aus, so ändert sich der Mauszeiger und man kann ein Rechteck ziehen; auf der Standardausgabe werden dann die vier Werte ausgegeben, die man <code class="language-plaintext highlighter-rouge">byzanz-record</code> als Koordinaten und Maße übergeben kann.</p>

<p>Um die Verwendung von Byzanz komfortabler zu gestalten, empfiehlt es sich, die verschiedenen Komponenten in einem Skript zu vereinigen.
Praktischerweise wurde uns diese Arbeit von einigen Nutzern im <a href="https://askubuntu.com/questions/107726/how-to-create-animated-gif-images-of-a-screencast">askubuntu-Forum</a> bereits abgenommen.
Insbesondere <a href="https://github.com/edouard-lopez/record-gif.sh">edouard-lopez/record-gif.sh</a> ist sehr hilfreich:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env bash</span>
<span class="nv">delay</span><span class="o">=</span>3
<span class="nv">duration</span><span class="o">=</span><span class="k">${</span><span class="nv">1</span><span class="k">:-</span><span class="nv">10</span><span class="k">}</span>
<span class="nv">save_as</span><span class="o">=</span><span class="k">${</span><span class="nv">2</span><span class="k">:-</span><span class="nv">$HOME</span><span class="p">/recorded.gif</span><span class="k">}</span>
<span class="nv">area</span><span class="o">=</span><span class="si">$(</span><span class="nb">shift </span>2<span class="p">;</span> <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span><span class="si">)</span>

<span class="nv">start_audio</span><span class="o">=</span>/usr/share/sounds/freedesktop/stereo/camera-shutter.oga
<span class="nv">end_audio</span><span class="o">=</span>/usr/share/sounds/freedesktop/stereo/complete.oga

notify<span class="o">()</span> <span class="o">{</span>
    <span class="nv">message</span><span class="o">=</span><span class="k">${</span><span class="nv">1</span><span class="k">:-</span><span class="s1">''</span><span class="k">}</span>
    <span class="nv">audio</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">2</span><span class="k">}</span><span class="s2">"</span>

    <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$message</span><span class="s2">"</span>
    <span class="k">if</span> <span class="o">[[</span> <span class="nt">-f</span> <span class="nv">$audio</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
      </span>paplay <span class="nv">$audio</span> &amp;
    <span class="k">fi</span>
<span class="o">}</span>

<span class="c"># xrectsel from https://github.com/lolilolicon/xrectsel</span>
select_area<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span>area
  <span class="nv">area</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">1</span><span class="k">}</span><span class="s2">"</span>

  <span class="k">if</span> <span class="o">[[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$area</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span><span class="nv">area</span><span class="o">=</span><span class="si">$(</span>xrectsel <span class="s2">"--x=%x --y=%y --width=%w --height=%h"</span><span class="si">)</span> <span class="o">||</span> <span class="nb">exit</span> <span class="nt">-1</span>
  <span class="k">fi

  </span><span class="nb">echo</span> <span class="nv">$area</span>
<span class="o">}</span>

countdown<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span><span class="nv">delay</span><span class="o">=</span><span class="nv">$1</span>

  <span class="nb">printf</span> <span class="s2">"Start recording in: "</span>
  <span class="k">for</span> <span class="o">((</span> <span class="nv">i</span><span class="o">=</span><span class="nv">$delay</span><span class="p">;</span> i&gt;0<span class="p">;</span> <span class="nt">--i</span> <span class="o">))</span> <span class="p">;</span> <span class="k">do
      </span><span class="nb">printf</span> <span class="s2">"%s</span><span class="se">\b</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$i</span><span class="s2">"</span>
      <span class="nb">sleep </span>1
  <span class="k">done
  </span><span class="nb">printf</span> <span class="s2">"</span><span class="se">\r</span><span class="s2">"</span>
<span class="o">}</span>

progress-bar<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span><span class="nv">duration</span><span class="o">=</span><span class="k">${</span><span class="nv">1</span><span class="k">}</span>


    already_done<span class="o">()</span> <span class="o">{</span> <span class="k">for</span> <span class="o">((</span><span class="k">done</span><span class="o">=</span>0<span class="p">;</span> <span class="k">done</span>&lt;<span class="nv">$elapsed</span><span class="p">;</span> <span class="k">done</span>++<span class="o">))</span><span class="p">;</span> <span class="k">do </span><span class="nb">printf</span> <span class="s2">"▇"</span><span class="p">;</span> <span class="k">done</span> <span class="o">}</span>
    remaining<span class="o">()</span> <span class="o">{</span> <span class="k">for</span> <span class="o">((</span><span class="nv">remain</span><span class="o">=</span><span class="nv">$elapsed</span><span class="p">;</span> remain&lt;<span class="nv">$duration</span><span class="p">;</span> remain++<span class="o">))</span><span class="p">;</span> <span class="k">do </span><span class="nb">printf</span> <span class="s2">" "</span><span class="p">;</span> <span class="k">done</span> <span class="o">}</span>
    percentage<span class="o">()</span> <span class="o">{</span> <span class="nb">printf</span> <span class="s2">"| %s%%"</span> <span class="k">$((</span> <span class="o">((</span><span class="nv">$elapsed</span><span class="o">)*</span><span class="m">100</span><span class="o">)/(</span><span class="nv">$duration</span><span class="o">)*</span><span class="m">100</span><span class="o">/</span><span class="m">100</span> <span class="k">))</span><span class="p">;</span> <span class="o">}</span>
    clean_line<span class="o">()</span> <span class="o">{</span> <span class="nb">printf</span> <span class="s2">"</span><span class="se">\r</span><span class="s2">"</span><span class="p">;</span> <span class="o">}</span>

  <span class="k">for</span> <span class="o">((</span> <span class="nv">elapsed</span><span class="o">=</span>1<span class="p">;</span> elapsed&lt;<span class="o">=</span><span class="nv">$duration</span><span class="p">;</span> elapsed++ <span class="o">))</span><span class="p">;</span> <span class="k">do
      </span>already_done<span class="p">;</span> remaining<span class="p">;</span> percentage
      <span class="nb">sleep </span>1
      clean_line
  <span class="k">done
  </span><span class="nb">printf</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span>
<span class="o">}</span>

remove_existing<span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">[[</span> <span class="nt">-f</span> <span class="nv">$save_as</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">rm</span> <span class="nv">$save_as</span>
    <span class="nb">printf</span> <span class="s2">"Existing record will be overwritten.</span><span class="se">\n</span><span class="s2">"</span>
  <span class="k">fi</span>
<span class="o">}</span>

create_replay<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span><span class="nv">seletected_area</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>
  <span class="nb">local </span><span class="nv">duration</span><span class="o">=</span><span class="nv">$2</span>
  <span class="nb">local </span><span class="nv">save_as</span><span class="o">=</span><span class="s2">"</span><span class="nv">$3</span><span class="s2">"</span>
  <span class="nb">local </span><span class="nv">executable</span><span class="o">=</span><span class="s2">"</span><span class="nv">$0</span><span class="s2">"</span>

  <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$executable</span><span class="s2"> </span><span class="nv">$duration</span><span class="s2"> </span><span class="nv">$save_as</span><span class="s2"> </span><span class="k">${</span><span class="nv">seletected_area</span><span class="k">}</span><span class="s2">"</span> <span class="o">&gt;</span> <span class="nv">$HOME</span>/.record.again
  <span class="nb">chmod </span>u+x <span class="nv">$HOME</span>/.record.again
<span class="o">}</span>
run<span class="o">()</span> <span class="o">{</span>
  <span class="nb">printf</span> <span class="s2">"Saving in %s%s</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$save_as</span><span class="s2">"</span>
  remove_existing
  <span class="nb">printf</span> <span class="s2">"Recording for %ss.</span><span class="se">\n\n</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$duration</span><span class="s2">"</span>
  <span class="nb">printf</span> <span class="s2">"Select Area to record…</span><span class="se">\n</span><span class="s2">"</span>

  <span class="nv">seletected_area</span><span class="o">=</span><span class="s2">"</span><span class="si">$(</span>select_area <span class="s2">"</span><span class="nv">$area</span><span class="s2">"</span><span class="si">)</span><span class="s2">"</span>
  countdown <span class="nv">$delay</span>
  create_replay <span class="s2">"</span><span class="nv">$seletected_area</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$duration</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$save_as</span><span class="s2">"</span>
  <span class="nb">printf</span> <span class="s2">"You can replay this recording by running: </span><span class="se">\n</span><span class="s2">  </span><span class="nv">$ </span><span class="s2">bash %s</span><span class="se">\n\n</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/.record.again"</span>
  notify <span class="s2">"Recording…                        "</span> <span class="s2">"</span><span class="nv">$start_audio</span><span class="s2">"</span>

  progress-bar <span class="nv">$duration</span> &amp;
  byzanz-record <span class="nt">--verbose</span> <span class="nt">--delay</span><span class="o">=</span>0 <span class="k">${</span><span class="nv">seletected_area</span><span class="k">}</span> <span class="nt">--duration</span><span class="o">=</span><span class="nv">$duration</span> <span class="nv">$save_as</span> <span class="o">&gt;</span> /dev/null

  notify <span class="s2">"Finished!"</span> <span class="s2">"</span><span class="nv">$end_audio</span><span class="s2">"</span>
<span class="o">}</span>

run
</code></pre></div></div>
<p>Nun kann eine Aufnahme nur eines Teilbereiches des Bildschirms sehr einfach gestartet werden:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>record-gif.sh DURATION FILENAME
</code></pre></div></div>

<h3 id="aufnahme-von-mauszeiger-audioausgabe-und-tastatureingaben">Aufnahme von Mauszeiger, Audioausgabe und Tastatureingaben</h3>
<p>In der Standardeinstellung wird von Byzanz lediglich das sichtbare Bild aufgenommen.
Soll auch die Audioausgabe aufgezeichnet werden, kann das <code class="language-plaintext highlighter-rouge">-a</code>-Flag (<code class="language-plaintext highlighter-rouge">--audio</code>) gesetzt werden.</p>

<p>Auch Benutzereingaben werden nicht ohne Weiteres aufgenommen.
Soll der Mauszeiger von der Aufnahme erfasst werden, muss das <code class="language-plaintext highlighter-rouge">-c</code>-Flag (<code class="language-plaintext highlighter-rouge">--cursor</code>) gesetzt werden. 
Leider verfügt Byzanz über keine Funktion, um die auf der Tastatur gedrückten Tasten zu visualisieren und aufzunehmen.
Da es aber Ausgaben von beliebigen anderen Tools aufzeichnet, kann das besonders populäre <a href="https://gitlab.com/screenkey/screenkey">Screenkey</a> gestartet werden, bevor man mit der Aufnahme beginnt.
Die ansprechend formatierten Tasten-Ausgaben sind dann Teil der Aufnahme, wie alle anderen sichtbaren Bildschirmelemente.</p>

<h3 id="workflow-und-beispiel">Workflow und Beispiel</h3>
<p>In diesem Abschnitt fasse ich den Workflow zusammen, dem ich folge, um Aufnahmen zu erstellen.
Zur Veranschaulichung habe ich einen Screencast davon erstellt, wie man einen mit Byzanz eine Bildschirmaufnahme erstellt und als GIF speichert:</p>
<ol>
  <li>Da verschiedene Terminal-Fenster benötigt werden, empfiehlt sich die Verwendung von <code class="language-plaintext highlighter-rouge">tmux</code> (oder einem anderen Terminal-Multiplexer). Man startete also zunächst am besten eine neue TMUX-Session.</li>
  <li>Dann öffnet man ein neues Terminal-Fenster, in dem Screenkey gestartet wird.</li>
  <li>Im ersten Fenster startet man das Byzanz-Skript und wählt im Anschluss den Aufnahmebereich aus. Danach verbleiben einige Sekunden, bevor die Aufnahme tatsächlich startet.</li>
  <li>Im Beispiel unten nutze ich diese Zeit, um ein weiteres Terminal-Fenster zu öffnen, in dem die eigentlich aufzuzeichnende Aktivität stattfinden wird. Darüber hinaus verwende ich die Verzögerung, um Vim zu starten. In der Folge könnte also ein Workflow innerhalb dieses Texteditors veranschaulicht werden. Das Resultat wäre ein Video, an dessem Beginn Vim bereits gestartet ist. Es wird durchgeführt, was veranschaulicht werden soll, und nach der als Länge angegebenen Zeit wird die Aufnahme automatisch beendet und in der spezifizierten Datei gespeichert.</li>
</ol>

<image src="/assets/images/record-gif.gif" alt="Beispiel einer Byzanz-Aufnahme" />

<h2 id="installation">Installation</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pacman <span class="nt">-S</span> screenkey
pacman <span class="nt">-S</span> byzanz
curl https://raw.githubusercontent.com/edouard-lopez/record-gif.sh/master/record-gif.sh <span class="o">&gt;</span> ~/.bin/recorrd-gif.sh <span class="c"># oder in einem anderen Verzeichnis für Binaries</span>

<span class="c"># Installation von xrectsel über AUR</span>
<span class="nb">cd</span> ~/builds
git clone https://aur.archlinux.org/xrectsel.git
<span class="nb">cd </span>xrectsel
makepkg <span class="nt">-si</span>
</code></pre></div></div>

<h2 id="anmerkungen">Anmerkungen</h2>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:2" role="doc-endnote">
      <p>Die doppelten Anführungszeichen sind wichtig, falls dem Befehl selbst wiederum Argumente übergeben werden. Der gesamte <code class="language-plaintext highlighter-rouge">byzanz-record</code>-Befehl wird von der Shell in mehreren Schritten interpretiert, bevor das Programm aufgerufen wird. In einem Schritt werden die Argumente <a href="https://www.gnu.org/software/bash/manual/bash.html#Word-Splitting">separiert</a>. Als ein <em>Wort</em> werden für gewöhnlich (sofern die <code class="language-plaintext highlighter-rouge">IFS</code>-Umgebungsvariable nicht neu definiert wird) Zeichenketten zwischen Leerzeichen aufgefasst. Im Rahmen des Byzanz-Aufrufs sollen nun jedoch mehrere Wörter <em>ein</em> Argument bilden, die auf der tieferen Ebene die verschiedenen Argumente eines anderen Befehls sind. Im Befehl <code class="language-plaintext highlighter-rouge">byzanz-record -e "echo Hello World"</code> ist <code class="language-plaintext highlighter-rouge">echo Hello World</code> <em>ein</em> Argument; der Befehl bewirkt jedoch, dass <code class="language-plaintext highlighter-rouge">echo Hello World</code> in einer neuen Subshell aufgerufen wird, und dann sind <code class="language-plaintext highlighter-rouge">Hello</code> und <code class="language-plaintext highlighter-rouge">World</code> zwei Argumente des <code class="language-plaintext highlighter-rouge">echo</code>-Befehls. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:1" role="doc-endnote">
      <p>Auf der verlinkten Online-Version der <code class="language-plaintext highlighter-rouge">man</code>-Page wird die Option <code class="language-plaintext highlighter-rouge">-e</code> bzw. <code class="language-plaintext highlighter-rouge">--execute</code> nicht genannt, wohl aber in der lokalen Version. Ich konnte nicht  in Erfahrung bringen, ob es sich dabei um eine Nachlässigkeit handelt oder ob verschiedene Releases von Byzanz im Umlauf sind, die sich in ihren Features unterscheiden. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    </article>
  </body>
</html>
